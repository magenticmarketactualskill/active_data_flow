#!/usr/bin/env ruby
# frozen_string_literal: true

# Unified Submoduler Entry Point
# This script automatically detects whether it's running in a parent or child
# context and delegates to the appropriate CLI.

require 'pathname'
require 'inifile'

# Determine project root (one level up from bin/)
PROJECT_ROOT = File.expand_path('..', __dir__)

# Add vendor paths to load path
# Order matters: common must be loaded first to avoid NameError
$LOAD_PATH.unshift File.join(PROJECT_ROOT, 'vendor', 'submoduler_common', 'lib')
$LOAD_PATH.unshift File.join(PROJECT_ROOT, 'vendor', 'submoduler_parent', 'lib')
$LOAD_PATH.unshift File.join(PROJECT_ROOT, 'vendor', 'submoduler_child', 'lib')

# Require dependencies
begin
  require 'submoduler_common/command'
  require 'submoduler_common/logger'
  require 'submoduler_common/git_helper'
  require 'submoduler_parent'
  require 'submoduler_child'
rescue LoadError => e
  puts "Error loading submoduler dependencies: #{e.message}"
  puts "Make sure vendor/submoduler_* directories exist and contain the required gems."
  exit 1
end

# Detect whether we're in a parent or child context
# by examining the .submoduler.ini configuration
def detect_context
  config_file = File.join(Dir.pwd, '.submoduler.ini')
  
  return :parent unless File.exist?(config_file)
  
  begin
    ini = IniFile.load(config_file)
    return :parent unless ini
    
    # Check if this is a child submodule
    # Child configs have either type='child' or a childname field
    submoduler_section = ini['submoduler']
    if submoduler_section
      return :child if submoduler_section['type'] == 'child'
      return :child if submoduler_section['childname']
    end
    
    # Default to parent if config exists but doesn't indicate child
    :parent
  rescue StandardError => e
    # If config parsing fails, default to parent and let CLI handle validation
    warn "Warning: Failed to parse .submoduler.ini: #{e.message}"
    :parent
  end
end

# Detect context and run appropriate CLI
context = detect_context

exit_code = if context == :child
              SubmodulerChild::CLI.run(ARGV)
            else
              SubmodulerParent::CLI.run(ARGV)
            end

exit exit_code