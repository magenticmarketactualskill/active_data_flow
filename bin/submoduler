#!/usr/bin/env ruby
# frozen_string_literal: true

# Unified Submoduler Entry Point
# This script automatically detects whether it's running in a parent or child
# context and delegates to the appropriate CLI.

require 'pathname'

# Determine project root (one level up from bin/)
PROJECT_ROOT = File.expand_path('..', __dir__)

# Add vendor paths to load path
# Order matters: common must be loaded first to avoid NameError
$LOAD_PATH.unshift File.join(PROJECT_ROOT, 'vendor', 'submoduler_common', 'lib')
$LOAD_PATH.unshift File.join(PROJECT_ROOT, 'vendor', 'submoduler_parent', 'lib')
$LOAD_PATH.unshift File.join(PROJECT_ROOT, 'vendor', 'submoduler_child', 'lib')

# Require dependencies
begin
  require 'submoduler_common/command'
  require 'submoduler_common/logger'
  require 'submoduler_common/git_helper'
  require 'submoduler_common/submoduler_ini'
  require 'submoduler_parent'
  require 'submoduler_child'
rescue LoadError => e
  puts "Error loading submoduler dependencies: #{e.message}"
  puts "Make sure vendor/submoduler_* directories exist and contain the required gems."
  exit 1
end

# Detect whether we're in a parent or child context
# by examining the .submoduler.ini configuration
def detect_context
  ini = SubmodulerCommon::SubmodulerIni.new
  return :parent unless ini.exist?
  
  begin
    ini.load_config
    ini.type
  rescue SubmodulerCommon::SubmodulerIni::ConfigError => e
    # If config parsing fails, default to parent and let CLI handle validation
    warn "Warning: Failed to parse .submoduler.ini: #{e.message}"
    :parent
  end
end

# Detect context and run appropriate CLI
context = detect_context

exit_code = if context == :child
              SubmodulerChild::CLI.run(ARGV)
            else
              SubmodulerParent::CLI.run(ARGV)
            end

exit exit_code